const UNLOCKED=0,LOCKED_NO_WAITERS=1,LOCKED_POSSIBLE_WAITERS=2,NUMINTS=1;class Lock{constructor(t,o){if(!(t instanceof Int32Array&&o|0===o&&o>=0&&o+NUMINTS<=t.length))throw new Error(`Bad arguments to Lock constructor: ${t} ${o}`);this.iab=t,this.ibase=o}static initialize(t,o){if(!(t instanceof Int32Array&&o|0===o&&o>=0&&o+NUMINTS<=t.length))throw new Error(`Bad arguments to Lock constructor: ${t} ${o}`);return Atomics.store(t,o,UNLOCKED),o}lock(){const t=this.iab,o=this.ibase;var s;if((s=Atomics.compareExchange(t,o,UNLOCKED,LOCKED_NO_WAITERS))!==UNLOCKED)do{s!==LOCKED_POSSIBLE_WAITERS&&Atomics.compareExchange(t,o,LOCKED_NO_WAITERS,LOCKED_POSSIBLE_WAITERS)===UNLOCKED||Atomics.wait(t,o,LOCKED_POSSIBLE_WAITERS,Number.POSITIVE_INFINITY)}while((s=Atomics.compareExchange(t,o,UNLOCKED,LOCKED_POSSIBLE_WAITERS))!==UNLOCKED)}tryLock(){const t=this.iab,o=this.ibase;return Atomics.compareExchange(t,o,UNLOCKED,LOCKED_NO_WAITERS)===UNLOCKED}unlock(){const t=this.iab,o=this.ibase;Atomics.sub(t,o,1)!==LOCKED_NO_WAITERS&&(Atomics.store(t,o,UNLOCKED),Atomics.wake(t,o,1))}toString(){return"Lock:{ibase:"+this.ibase+"}"}}